# CardNews AI Generator - 개발 문서

**Last Updated**: 2025-10-25

## 📢 최근 업데이트

### ✅ Phase 1 완료 (2025년 10월)

#### 🌍 다국어 지원
- 영어, 한국어, 일본어 자동 감지
- 언어별 시스템 메시지 분리
- 원문 언어로 요약/키워드/카드뉴스 생성

#### 🔗 다중 URL 입력
- 여러 URL을 줄바꿈으로 구분하여 입력
- 자동으로 모든 URL 스크래핑 및 통합
- 출처별 명확한 구분선

#### 🤖 AI 모델 선택
- GPT-4.1 Nano (기본) - $0.10/1M
- GPT-4.1 Mini - $0.15/1M
- GPT-5 Nano - $0.20/1M
- GPT-5 Mini - $0.25/1M

#### 💬 자연어 처리 대폭 개선
- Function Call 통합 (modify_all_content)
- 무제한 자연어 명령 지원
- "존댓말로 바꿔줘" 등 자유로운 수정
- 프롬프트 강화 (Before/After 예시)

#### 🎨 UI/UX 개선
- 텍스트 입력 가시성 개선
- AI 모델 카드 선택 UI
- OpenAI 연결 상태 표시
- 카드 시작 옵션 (제목/내용)

#### 🚀 프로덕션 배포
- Frontend: Vercel
- Backend: Render
- CORS 와일드카드 (모든 Vercel URL)

---

### 🆕 Phase 2 계획 (RSS Core Features) - 2025년 10월

**RSS 크롤링 및 자동 생성 핵심 기능만 (최대 단순화)**

#### 주요 목표
- 📡 **RSS 전용**: RSS 피드가 있는 사이트만 지원 (빠른 개발)
- 💾 **DB 통합**: 모든 프로젝트 Firestore에 영구 저장 (3개 컬렉션)
- 🎯 **핵심 플로우**: RSS 크롤링 → 카드뉴스 생성 → DB 저장
- ⚡ **개발 기간**: **2-3주** (인증/알림 제외)
- 🚫 **제외**: 이메일 알림, 사용자 인증 (Phase 3로 이동)

#### 타겟 사이트 (RSS 지원)
1. https://blogs.microsoft.com/ (RSS: /feed/)
2. https://www.microsoft.com/en-us/security (RSS 확인)
3. 기타 RSS 지원 기술 블로그

#### 핵심 기능 (4개)
1. **RSS 크롤링 시스템**: `feedparser` 사용
2. **자동 생성 파이프라인**: 사용자 개입 없이 완전 자동
3. **프로젝트 관리**: 저장, 수정, 버전 관리
4. **메인 대시보드**: 3개 메뉴 (RSS 설정 / Phase 1 / 프로젝트)

**상세 개발 계획**: [PHASE2_SPEC.md](../PHASE2_SPEC.md) 참조

---

### 📌 Phase 3 계획 (Auth, Notification & Design) - 미래

**인증, 알림 및 디자인 기능 추가**

#### 추가 기능
1. **사용자 인증**: Firebase Auth (이메일, Google, GitHub)
2. **이메일 알림**: SendGrid 통합, 사용자별 이메일 관리
3. **웹 스크래핑**: Playwright로 RSS 없는 사이트 크롤링
4. **디자인 시스템**: 템플릿, 색상, 폰트 커스터마이징
5. **이미지 통합**: AI 이미지 생성 및 편집
6. **내보내기**: PNG, PDF 형식 다운로드
7. **팀 협업**: 프로젝트 공유 및 댓글

---

## 목차
1. [프로젝트 구조](#1-프로젝트-구조)
2. [개발 환경 설정](#2-개발-환경-설정)
3. [Backend 상세 설계](#3-backend-상세-설계)
4. [Frontend 상세 설계](#4-frontend-상세-설계)
5. [AI 통합 가이드](#5-ai-통합-가이드)
6. [데이터베이스 설계](#6-데이터베이스-설계)
7. [API 상세 명세](#7-api-상세-명세)
8. [배포 가이드](#8-배포-가이드)
9. [테스트 전략](#9-테스트-전략)
10. [보안 고려사항](#10-보안-고려사항)

---

## 1. 프로젝트 구조

### 1.1 전체 디렉토리 구조

```
CardNews/
├── backend/                      # Python FastAPI 백엔드
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py              # FastAPI 앱 진입점
│   │   ├── config.py            # 환경 변수 및 설정
│   │   ├── models/              # Pydantic 모델
│   │   │   ├── __init__.py
│   │   │   ├── project.py
│   │   │   ├── section.py
│   │   │   └── chat.py
│   │   ├── services/            # 비즈니스 로직
│   │   │   ├── __init__.py
│   │   │   ├── scraper.py       # 웹 스크래핑
│   │   │   ├── summarizer.py    # AI 요약
│   │   │   ├── card_generator.py # 카드 생성
│   │   │   └── chat_service.py  # AI 채팅
│   │   ├── routers/             # API 라우터
│   │   │   ├── __init__.py
│   │   │   ├── projects.py
│   │   │   ├── sections.py
│   │   │   └── chat.py
│   │   ├── utils/               # 유틸리티 함수
│   │   │   ├── __init__.py
│   │   │   ├── firebase.py      # Firebase 연동
│   │   │   ├── validators.py
│   │   │   └── prompts.py       # AI 프롬프트 템플릿
│   │   └── tests/               # 백엔드 테스트
│   │       ├── __init__.py
│   │       ├── test_scraper.py
│   │       ├── test_summarizer.py
│   │       └── test_api.py
│   ├── requirements.txt         # Python 의존성
│   ├── .env.example            # 환경 변수 예시
│   └── Dockerfile              # Docker 설정 (선택)
│
├── frontend/                    # React/Next.js 프론트엔드
│   ├── public/
│   │   ├── favicon.ico
│   │   └── images/
│   ├── src/
│   │   ├── components/          # 재사용 가능한 컴포넌트
│   │   │   ├── common/
│   │   │   │   ├── Button.tsx
│   │   │   │   ├── Input.tsx
│   │   │   │   └── LoadingSpinner.tsx
│   │   │   ├── layout/
│   │   │   │   ├── Header.tsx
│   │   │   │   └── Footer.tsx
│   │   │   ├── source/
│   │   │   │   ├── SourceInput.tsx      # Step 1: 소스 입력
│   │   │   │   └── UrlValidator.tsx
│   │   │   ├── summary/
│   │   │   │   ├── SummaryView.tsx      # Step 2: 요약 표시
│   │   │   │   └── KeywordBadges.tsx
│   │   │   ├── cardnews/
│   │   │   │   ├── CardList.tsx         # Step 3: 카드 목록
│   │   │   │   ├── CardPreview.tsx      # 개별 카드 미리보기
│   │   │   │   └── CardEditor.tsx
│   │   │   └── chat/
│   │   │       ├── ChatInterface.tsx    # AI 채팅 UI
│   │   │       └── MessageBubble.tsx
│   │   ├── pages/               # Next.js 페이지
│   │   │   ├── index.tsx        # 홈/프로젝트 생성
│   │   │   ├── project/
│   │   │   │   └── [id].tsx     # 프로젝트 상세
│   │   │   └── _app.tsx
│   │   ├── hooks/               # 커스텀 훅
│   │   │   ├── useProject.ts
│   │   │   ├── useChat.ts
│   │   │   └── useFirebase.ts
│   │   ├── services/            # API 통신
│   │   │   ├── api.ts           # Axios 설정
│   │   │   ├── projectService.ts
│   │   │   └── chatService.ts
│   │   ├── store/               # 상태 관리 (Zustand)
│   │   │   ├── projectStore.ts
│   │   │   └── uiStore.ts
│   │   ├── styles/
│   │   │   └── globals.css      # Tailwind CSS
│   │   ├── types/               # TypeScript 타입
│   │   │   ├── project.ts
│   │   │   └── section.ts
│   │   └── utils/
│   │       ├── firebase.ts      # Firebase 초기화
│   │       └── constants.ts
│   ├── package.json
│   ├── tsconfig.json
│   ├── tailwind.config.js
│   ├── next.config.js
│   └── .env.local.example
│
├── docs/                        # 추가 문서
│   ├── API.md
│   └── DEPLOYMENT.md
├── .gitignore
├── README.md
├── PRD.md                       # 제품 요구사항 문서
└── 개발문서.md                  # 이 문서
```

---

## 2. 개발 환경 설정

### 2.1 필수 도구 설치

| 도구 | 버전 | 설치 명령 |
|------|------|-----------|
| **Python** | 3.11+ | `brew install python@3.11` (macOS) |
| **Node.js** | 18+ | `brew install node` |
| **Firebase CLI** | 최신 | `npm install -g firebase-tools` |
| **Git** | 최신 | `brew install git` |

### 2.2 Backend 환경 설정

#### Step 1: 가상환경 생성
```bash
cd backend
python -m venv venv
source venv/bin/activate  # macOS/Linux
# Windows: venv\Scripts\activate
```

#### Step 2: 의존성 설치
```bash
pip install -r requirements.txt
```

#### Step 3: 환경 변수 설정
`.env` 파일 생성 (`.env.example` 참고):
```env
# OpenAI API
OPENAI_API_KEY=sk-your-api-key-here
OPENAI_MODEL=gpt-4o-mini

# Firebase
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_PRIVATE_KEY_PATH=./serviceAccountKey.json

# Backend 설정
BACKEND_PORT=8000
ALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com

# 기타
MAX_TEXT_LENGTH=10000
DEBUG=True
```

### 2.3 Frontend 환경 설정

#### Step 1: 의존성 설치
```bash
cd frontend
npm install
# 또는
yarn install
```

#### Step 2: 환경 변수 설정
`.env.local` 파일 생성:
```env
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_FIREBASE_API_KEY=your-api-key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your-project-id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your-project.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=123456789
NEXT_PUBLIC_FIREBASE_APP_ID=1:123456789:web:abcdef
```

### 2.4 Firebase 프로젝트 설정

#### Step 1: Firebase 프로젝트 생성
```bash
firebase login
firebase init
```

선택 옵션:
- ✅ Hosting
- ✅ Firestore
- ✅ Functions (선택사항)
- ✅ Storage

#### Step 2: Firestore 보안 규칙 설정
`firestore.rules`:
```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // 프로젝트 문서
    match /projects/{projectId} {
      allow read, write: if true; // Phase 1: 인증 없음
      // Phase 2: allow read, write: if request.auth != null;
      
      // 카드 섹션 하위 컬렉션
      match /sections/{sectionId} {
        allow read, write: if true;
      }
      
      // 대화 이력 하위 컬렉션
      match /conversations/{conversationId} {
        allow read, write: if true;
      }
    }
  }
}
```

---

## 3. Backend 상세 설계

### 3.1 FastAPI 앱 구조

#### `main.py` - 앱 진입점
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.config import settings
from app.routers import projects, sections, chat

# FastAPI 앱 초기화
app = FastAPI(
    title="CardNews AI API",
    description="AI 기반 카드뉴스 생성 API",
    version="1.0.0"
)

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 라우터 등록
app.include_router(projects.router, prefix="/api/projects", tags=["projects"])
app.include_router(sections.router, prefix="/api/sections", tags=["sections"])
app.include_router(chat.router, prefix="/api/chat", tags=["chat"])

@app.get("/")
async def root():
    return {"message": "CardNews AI API", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

### 3.2 핵심 서비스 모듈

#### `services/scraper.py` - 웹 스크래핑
```python
from bs4 import BeautifulSoup
import requests
from newspaper import Article
from typing import Dict, Optional

class WebScraper:
    """웹 페이지에서 본문 텍스트를 추출하는 서비스"""
    
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
    
    def scrape_url(self, url: str) -> Dict[str, str]:
        """
        URL에서 제목과 본문을 추출
        
        Args:
            url: 스크래핑할 웹 페이지 URL
            
        Returns:
            {'title': str, 'content': str, 'authors': list, 'publish_date': str}
        """
        try:
            # newspaper3k 사용 (뉴스 기사에 최적화)
            article = Article(url, language='ko')
            article.download()
            article.parse()
            
            return {
                'title': article.title,
                'content': article.text,
                'authors': article.authors,
                'publish_date': str(article.publish_date) if article.publish_date else None,
                'top_image': article.top_image
            }
        except Exception as e:
            # Fallback: BeautifulSoup 사용
            return self._fallback_scrape(url)
    
    def _fallback_scrape(self, url: str) -> Dict[str, str]:
        """newspaper3k 실패 시 BeautifulSoup으로 스크래핑"""
        response = requests.get(url, headers=self.headers, timeout=10)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # 제목 추출
        title = soup.find('h1')
        title_text = title.get_text().strip() if title else "제목 없음"
        
        # 본문 추출 (일반적인 article 태그 우선)
        article = soup.find('article')
        if article:
            paragraphs = article.find_all('p')
        else:
            paragraphs = soup.find_all('p')
        
        content = '\n'.join([p.get_text().strip() for p in paragraphs])
        
        return {
            'title': title_text,
            'content': content,
            'authors': [],
            'publish_date': None,
            'top_image': None
        }
```

#### `services/summarizer.py` - AI 요약
```python
from openai import OpenAI
from typing import Dict, List
from app.config import settings
from app.utils.prompts import SUMMARIZE_PROMPT, KEYWORD_EXTRACTION_PROMPT

class AISummarizer:
    """OpenAI API를 사용한 텍스트 요약 서비스"""
    
    def __init__(self):
        self.client = OpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL
    
    def summarize(self, text: str, max_length: int = 200) -> Dict:
        """
        텍스트를 요약하고 키워드 추출
        
        Args:
            text: 요약할 원본 텍스트
            max_length: 요약문 최대 길이
            
        Returns:
            {
                'summary': str,          # 핵심 요약
                'keywords': List[str],   # 주요 키워드
                'card_count': int        # 추천 카드 수
            }
        """
        # 1. 핵심 요약 생성
        summary = self._generate_summary(text, max_length)
        
        # 2. 키워드 추출
        keywords = self._extract_keywords(text)
        
        # 3. 카드 수 추천 (텍스트 길이 기반)
        card_count = self._recommend_card_count(text)
        
        return {
            'summary': summary,
            'keywords': keywords,
            'card_count': card_count
        }
    
    def _generate_summary(self, text: str, max_length: int) -> str:
        """GPT를 사용하여 요약 생성"""
        prompt = SUMMARIZE_PROMPT.format(text=text, max_length=max_length)
        
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": "당신은 전문 콘텐츠 요약 전문가입니다."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,  # 일관성 있는 요약을 위해 낮은 온도
            max_tokens=500
        )
        
        return response.choices[0].message.content.strip()
    
    def _extract_keywords(self, text: str, count: int = 5) -> List[str]:
        """GPT를 사용하여 키워드 추출"""
        prompt = KEYWORD_EXTRACTION_PROMPT.format(text=text, count=count)
        
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {"role": "system", "content": "당신은 키워드 추출 전문가입니다."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=100
        )
        
        keywords_text = response.choices[0].message.content.strip()
        # 쉼표로 구분된 키워드를 리스트로 변환
        keywords = [k.strip() for k in keywords_text.split(',')]
        
        return keywords[:count]
    
    def _recommend_card_count(self, text: str) -> int:
        """텍스트 길이에 따라 카드 수 추천"""
        length = len(text)
        
        if length < 500:
            return 3  # 제목 + 내용 1개 + 마무리
        elif length < 1500:
            return 5  # 제목 + 내용 3개 + 마무리
        elif length < 3000:
            return 7  # 제목 + 내용 5개 + 마무리
        else:
            return 9  # 제목 + 내용 7개 + 마무리
```

#### `services/card_generator.py` - 카드뉴스 생성
```python
from typing import List, Dict
from openai import OpenAI
from app.models.section import CardSection, CardType
from app.config import settings
from app.utils.prompts import CARD_GENERATION_PROMPT

class CardNewsGenerator:
    """AI를 사용하여 카드뉴스 섹션 자동 생성"""
    
    def __init__(self):
        self.client = OpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL
    
    def generate_sections(
        self, 
        summary: str, 
        original_text: str, 
        card_count: int
    ) -> List[Dict]:
        """
        요약본과 원문을 바탕으로 카드뉴스 섹션 생성
        
        Args:
            summary: 요약된 텍스트
            original_text: 원본 텍스트
            card_count: 생성할 카드 수
            
        Returns:
            List of card sections
        """
        # GPT에게 카드뉴스 구조 생성 요청
        prompt = CARD_GENERATION_PROMPT.format(
            summary=summary,
            original_text=original_text[:3000],  # 토큰 제한 고려
            card_count=card_count
        )
        
        response = self.client.chat.completions.create(
            model=self.model,
            messages=[
                {
                    "role": "system", 
                    "content": "당신은 카드뉴스 제작 전문가입니다. 주어진 내용을 카드뉴스 형식으로 구조화합니다."
                },
                {"role": "user", "content": prompt}
            ],
            temperature=0.5,
            max_tokens=2000
        )
        
        # 응답 파싱 (JSON 형식으로 반환되도록 프롬프트 설계)
        import json
        card_data = json.loads(response.choices[0].message.content)
        
        # CardSection 모델로 변환
        sections = []
        for idx, card in enumerate(card_data['cards']):
            sections.append({
                'order': idx,
                'type': card.get('type', 'content'),
                'title': card.get('title', ''),
                'content': card.get('content', ''),
                'design_config': {
                    'background_color': '#FFFFFF',
                    'font_family': 'Pretendard',
                    'font_size': 16
                }
            })
        
        return sections
```

#### `services/chat_service.py` - AI 채팅 및 섹션 수정
```python
from typing import List, Dict
from openai import OpenAI
from app.config import settings
from app.utils.prompts import CHAT_SYSTEM_PROMPT

class ChatService:
    """AI와 대화하며 카드뉴스 섹션을 수정하는 서비스"""
    
    def __init__(self):
        self.client = OpenAI(api_key=settings.OPENAI_API_KEY)
        self.model = settings.OPENAI_MODEL
    
    def process_chat_message(
        self,
        user_message: str,
        current_sections: List[Dict],
        conversation_history: List[Dict] = None
    ) -> Dict:
        """
        사용자의 채팅 메시지를 처리하고 섹션 수정 제안
        
        Args:
            user_message: 사용자 메시지 ("두 번째 카드 더 간결하게 해줘")
            current_sections: 현재 카드 섹션 상태
            conversation_history: 이전 대화 이력
            
        Returns:
            {
                'ai_response': str,              # AI의 응답 메시지
                'updated_sections': List[Dict],  # 수정된 섹션 (있을 경우)
                'action_taken': str              # 수행한 작업 ('modify', 'reorder', 'none')
            }
        """
        # 대화 컨텍스트 구성
        messages = [
            {"role": "system", "content": CHAT_SYSTEM_PROMPT}
        ]
        
        # 이전 대화 이력 추가
        if conversation_history:
            messages.extend(conversation_history[-5:])  # 최근 5개만
        
        # 현재 섹션 정보 포함
        sections_context = self._format_sections_for_context(current_sections)
        messages.append({
            "role": "system",
            "content": f"현재 카드 섹션 상태:\n{sections_context}"
        })
        
        # 사용자 메시지 추가
        messages.append({
            "role": "user",
            "content": user_message
        })
        
        # GPT 호출
        response = self.client.chat.completions.create(
            model=self.model,
            messages=messages,
            temperature=0.7,
            max_tokens=1000,
            functions=[  # Function calling으로 섹션 수정 명령 구조화
                {
                    "name": "modify_section",
                    "description": "특정 카드 섹션의 내용을 수정",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "section_index": {"type": "integer"},
                            "new_title": {"type": "string"},
                            "new_content": {"type": "string"}
                        }
                    }
                },
                {
                    "name": "reorder_sections",
                    "description": "카드 섹션의 순서를 변경",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "new_order": {
                                "type": "array",
                                "items": {"type": "integer"}
                            }
                        }
                    }
                }
            ]
        )
        
        # 응답 처리
        choice = response.choices[0]
        
        if choice.message.function_call:
            # Function call이 있으면 섹션 수정 수행
            return self._handle_function_call(
                choice.message.function_call,
                current_sections
            )
        else:
            # 일반 대화 응답
            return {
                'ai_response': choice.message.content,
                'updated_sections': None,
                'action_taken': 'none'
            }
    
    def _format_sections_for_context(self, sections: List[Dict]) -> str:
        """섹션 정보를 GPT가 이해하기 쉬운 형식으로 포맷"""
        formatted = []
        for idx, section in enumerate(sections):
            formatted.append(
                f"카드 {idx + 1} ({section['type']}):\n"
                f"  제목: {section.get('title', 'N/A')}\n"
                f"  내용: {section.get('content', '')[:100]}..."
            )
        return '\n\n'.join(formatted)
    
    def _handle_function_call(self, function_call, current_sections: List[Dict]) -> Dict:
        """Function call 처리하여 섹션 수정"""
        import json
        
        function_name = function_call.name
        arguments = json.loads(function_call.arguments)
        
        updated_sections = current_sections.copy()
        
        if function_name == "modify_section":
            idx = arguments['section_index']
            if 0 <= idx < len(updated_sections):
                updated_sections[idx]['title'] = arguments.get('new_title', updated_sections[idx]['title'])
                updated_sections[idx]['content'] = arguments.get('new_content', updated_sections[idx]['content'])
            
            return {
                'ai_response': f"카드 {idx + 1}의 내용을 수정했습니다.",
                'updated_sections': updated_sections,
                'action_taken': 'modify'
            }
        
        elif function_name == "reorder_sections":
            new_order = arguments['new_order']
            updated_sections = [current_sections[i] for i in new_order]
            # order 필드 업데이트
            for idx, section in enumerate(updated_sections):
                section['order'] = idx
            
            return {
                'ai_response': "카드 순서를 변경했습니다.",
                'updated_sections': updated_sections,
                'action_taken': 'reorder'
            }
        
        return {
            'ai_response': "요청을 처리할 수 없습니다.",
            'updated_sections': None,
            'action_taken': 'none'
        }
```

### 3.3 Pydantic 모델 정의

#### `models/project.py`
```python
from pydantic import BaseModel, HttpUrl, validator
from typing import Optional, List, Literal
from datetime import datetime

class ProjectCreate(BaseModel):
    """프로젝트 생성 요청"""
    source_type: Literal['url', 'text']
    source_content: str
    
    @validator('source_content')
    def validate_content_length(cls, v):
        if len(v) > 10000:
            raise ValueError('텍스트는 10,000자를 초과할 수 없습니다.')
        if len(v.strip()) == 0:
            raise ValueError('내용이 비어있습니다.')
        return v

class ProjectResponse(BaseModel):
    """프로젝트 응답"""
    id: str
    source_type: str
    source_content: str
    summary: Optional[str] = None
    keywords: Optional[List[str]] = None
    created_at: datetime
    updated_at: datetime
    status: Literal['draft', 'summarized', 'completed']
    
    class Config:
        from_attributes = True

class SummarizeRequest(BaseModel):
    """요약 요청"""
    max_length: int = 200

class SummarizeResponse(BaseModel):
    """요약 응답"""
    summary: str
    keywords: List[str]
    recommended_card_count: int
```

#### `models/section.py`
```python
from pydantic import BaseModel
from typing import Optional, Literal, Dict

class CardSection(BaseModel):
    """카드 섹션 모델"""
    id: Optional[str] = None
    project_id: str
    order: int
    type: Literal['title', 'content', 'closing']
    title: Optional[str] = None
    content: str
    image_url: Optional[str] = None
    design_config: Dict = {
        'background_color': '#FFFFFF',
        'font_family': 'Pretendard',
        'font_size': 16
    }

class SectionCreate(BaseModel):
    """섹션 생성 요청"""
    order: int
    type: Literal['title', 'content', 'closing']
    title: Optional[str] = None
    content: str

class SectionUpdate(BaseModel):
    """섹션 수정 요청"""
    title: Optional[str] = None
    content: Optional[str] = None
    order: Optional[int] = None
```

### 3.4 프롬프트 템플릿

#### `utils/prompts.py`
```python
# 요약 프롬프트
SUMMARIZE_PROMPT = """
다음 텍스트를 {max_length}자 이내로 핵심 내용만 요약해주세요.
카드뉴스에 사용될 요약이므로, 명확하고 간결하게 작성해주세요.

텍스트:
{text}

요약:
"""

# 키워드 추출 프롬프트
KEYWORD_EXTRACTION_PROMPT = """
다음 텍스트에서 핵심 키워드 {count}개를 추출해주세요.
쉼표로 구분하여 나열해주세요.

텍스트:
{text}

키워드:
"""

# 카드뉴스 생성 프롬프트
CARD_GENERATION_PROMPT = """
다음 요약과 원문을 바탕으로 {card_count}개의 카드뉴스를 제작해주세요.

요약:
{summary}

원문:
{original_text}

다음 JSON 형식으로 응답해주세요:
{{
    "cards": [
        {{
            "type": "title",
            "title": "제목",
            "content": "부제목 또는 설명"
        }},
        {{
            "type": "content",
            "title": "섹션 제목",
            "content": "섹션 내용 (2-3문장)"
        }},
        ...
        {{
            "type": "closing",
            "title": "마무리 제목",
            "content": "마무리 멘트"
        }}
    ]
}}

규칙:
1. 첫 번째 카드는 반드시 "title" 타입
2. 마지막 카드는 반드시 "closing" 타입
3. 나머지는 "content" 타입
4. 각 카드의 내용은 간결하고 명확하게
5. 제목은 10자 이내, 내용은 100자 이내
"""

# 채팅 시스템 프롬프트
CHAT_SYSTEM_PROMPT = """
당신은 카드뉴스 제작을 돕는 AI 어시스턴트입니다.
사용자의 요청에 따라 카드 섹션을 수정하거나 재구성할 수 있습니다.

가능한 작업:
1. 특정 카드의 내용 수정
2. 카드 순서 변경
3. 카드 추가/삭제 제안
4. 더 나은 표현 제안

사용자가 "두 번째 카드"라고 하면 index 1을 의미합니다 (0-based).
수정 시 modify_section 함수를 호출하세요.
순서 변경 시 reorder_sections 함수를 호출하세요.
"""
```

---

## 4. Frontend 상세 설계

### 4.1 페이지 플로우

```
1. 홈 페이지 (/)
   ↓
2. 소스 입력 (URL 또는 텍스트)
   ↓
3. 요약 생성 (로딩 → 요약 결과 표시)
   ↓
4. 카드뉴스 섹션 생성
   ↓
5. AI 채팅으로 수정
   ↓
6. 완료 (Phase 2: Export)
```

### 4.2 핵심 컴포넌트

#### `components/source/SourceInput.tsx`
```typescript
import { useState } from 'react';
import { useRouter } from 'next/router';
import { createProject } from '@/services/projectService';

type SourceType = 'url' | 'text';

export default function SourceInput() {
  const [sourceType, setSourceType] = useState<SourceType>('url');
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      // 프로젝트 생성 API 호출
      const project = await createProject({
        source_type: sourceType,
        source_content: content
      });

      // 프로젝트 상세 페이지로 이동
      router.push(`/project/${project.id}`);
    } catch (error) {
      console.error('프로젝트 생성 실패:', error);
      alert('오류가 발생했습니다. 다시 시도해주세요.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-8">카드뉴스 제작 시작</h1>
      
      {/* 소스 타입 선택 */}
      <div className="mb-6 flex gap-4">
        <button
          onClick={() => setSourceType('url')}
          className={`px-6 py-3 rounded-lg ${
            sourceType === 'url' 
              ? 'bg-blue-600 text-white' 
              : 'bg-gray-200'
          }`}
        >
          URL 링크
        </button>
        <button
          onClick={() => setSourceType('text')}
          className={`px-6 py-3 rounded-lg ${
            sourceType === 'text' 
              ? 'bg-blue-600 text-white' 
              : 'bg-gray-200'
          }`}
        >
          텍스트 직접 입력
        </button>
      </div>

      {/* 입력 폼 */}
      <form onSubmit={handleSubmit}>
        {sourceType === 'url' ? (
          <input
            type="url"
            placeholder="https://example.com/article"
            value={content}
            onChange={(e) => setContent(e.target.value)}
            className="w-full px-4 py-3 border rounded-lg mb-4"
            required
          />
        ) : (
          <textarea
            placeholder="카드뉴스로 만들 내용을 입력하세요..."
            value={content}
            onChange={(e) => setContent(e.target.value)}
            className="w-full px-4 py-3 border rounded-lg mb-4 h-64"
            maxLength={10000}
            required
          />
        )}

        <button
          type="submit"
          disabled={loading}
          className="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 disabled:opacity-50"
        >
          {loading ? '처리 중...' : '카드뉴스 만들기'}
        </button>
      </form>
    </div>
  );
}
```

#### `pages/project/[id].tsx`
```typescript
import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import { getProject, summarizeProject, generateSections } from '@/services/projectService';
import SummaryView from '@/components/summary/SummaryView';
import CardList from '@/components/cardnews/CardList';
import ChatInterface from '@/components/chat/ChatInterface';

export default function ProjectPage() {
  const router = useRouter();
  const { id } = router.query;
  
  const [project, setProject] = useState(null);
  const [sections, setSections] = useState([]);
  const [step, setStep] = useState<'summarize' | 'generate' | 'edit'>('summarize');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (id) {
      loadProject();
    }
  }, [id]);

  const loadProject = async () => {
    try {
      const data = await getProject(id as string);
      setProject(data);
      
      // 상태에 따라 step 결정
      if (!data.summary) {
        setStep('summarize');
      } else if (sections.length === 0) {
        setStep('generate');
      } else {
        setStep('edit');
      }
    } catch (error) {
      console.error('프로젝트 로드 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSummarize = async () => {
    setLoading(true);
    try {
      const summary = await summarizeProject(id as string);
      setProject({ ...project, ...summary });
      setStep('generate');
    } catch (error) {
      console.error('요약 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleGenerateSections = async () => {
    setLoading(true);
    try {
      const generatedSections = await generateSections(id as string);
      setSections(generatedSections);
      setStep('edit');
    } catch (error) {
      console.error('섹션 생성 실패:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div className="flex justify-center items-center h-screen">로딩 중...</div>;
  }

  return (
    <div className="container mx-auto p-6">
      {/* Step 2: 요약 */}
      {step === 'summarize' && (
        <div>
          <h2 className="text-2xl font-bold mb-4">소스 분석 중...</h2>
          <button
            onClick={handleSummarize}
            className="bg-blue-600 text-white px-6 py-3 rounded-lg"
          >
            요약 시작
          </button>
        </div>
      )}

      {/* Step 3: 카드 생성 */}
      {step === 'generate' && project?.summary && (
        <div>
          <SummaryView
            summary={project.summary}
            keywords={project.keywords}
            recommendedCardCount={project.recommended_card_count}
          />
          <button
            onClick={handleGenerateSections}
            className="mt-6 bg-blue-600 text-white px-6 py-3 rounded-lg"
          >
            카드뉴스 생성
          </button>
        </div>
      )}

      {/* Step 4: 편집 */}
      {step === 'edit' && (
        <div className="grid grid-cols-2 gap-6">
          <div>
            <h2 className="text-2xl font-bold mb-4">카드 미리보기</h2>
            <CardList sections={sections} />
          </div>
          <div>
            <h2 className="text-2xl font-bold mb-4">AI와 대화하며 수정</h2>
            <ChatInterface
              projectId={id as string}
              sections={sections}
              onSectionsUpdate={setSections}
            />
          </div>
        </div>
      )}
    </div>
  );
}
```

### 4.3 API 서비스

#### `services/projectService.ts`
```typescript
import api from './api';

export interface Project {
  id: string;
  source_type: 'url' | 'text';
  source_content: string;
  summary?: string;
  keywords?: string[];
  created_at: string;
  updated_at: string;
  status: 'draft' | 'summarized' | 'completed';
}

export const createProject = async (data: {
  source_type: 'url' | 'text';
  source_content: string;
}): Promise<Project> => {
  const response = await api.post('/api/projects', data);
  return response.data;
};

export const getProject = async (id: string): Promise<Project> => {
  const response = await api.get(`/api/projects/${id}`);
  return response.data;
};

export const summarizeProject = async (id: string) => {
  const response = await api.post(`/api/projects/${id}/summarize`);
  return response.data;
};

export const generateSections = async (id: string) => {
  const response = await api.post(`/api/projects/${id}/sections`);
  return response.data;
};
```

---

## 5. AI 통합 가이드

### 5.1 OpenAI API 설정

#### 요금 최적화 전략
| 모델 | 용도 | 1M 토큰당 비용 |
|------|------|----------------|
| `gpt-4o-mini` | 요약, 키워드 추출 | $0.15 (입력) |
| `gpt-4o` | 복잡한 카드 생성 | $2.50 (입력) |

**추천**: Phase 1은 `gpt-4o-mini`로 시작하여 비용 절감

### 5.2 토큰 사용량 최적화

```python
# 토큰 계산 (대략 한글 1글자 = 2-3토큰)
def estimate_tokens(text: str) -> int:
    return len(text) * 2.5

# 텍스트 자르기
def truncate_text(text: str, max_tokens: int = 3000) -> str:
    max_chars = int(max_tokens / 2.5)
    return text[:max_chars]
```

---

## 6. 데이터베이스 설계

### 6.1 Firestore 컬렉션 구조

```
firestore/
├── projects/                    # 프로젝트 컬렉션
│   ├── {projectId}/            # 문서 ID
│   │   ├── source_type         # 'url' | 'text'
│   │   ├── source_content      # 원본 소스
│   │   ├── summary             # 요약문
│   │   ├── keywords            # 키워드 배열
│   │   ├── created_at          # Timestamp
│   │   ├── updated_at          # Timestamp
│   │   ├── status              # 'draft' | 'summarized' | 'completed'
│   │   │
│   │   ├── sections/           # 하위 컬렉션: 카드 섹션
│   │   │   ├── {sectionId}/
│   │   │   │   ├── order       # 순서 (정수)
│   │   │   │   ├── type        # 'title' | 'content' | 'closing'
│   │   │   │   ├── title       # 제목
│   │   │   │   ├── content     # 내용
│   │   │   │   ├── image_url   # 이미지 URL (Phase 2)
│   │   │   │   └── design_config # 디자인 설정 (Map)
│   │   │
│   │   └── conversations/      # 하위 컬렉션: AI 대화 이력
│   │       ├── {conversationId}/
│   │       │   ├── user_message
│   │       │   ├── ai_response
│   │       │   └── timestamp
```

### 6.2 인덱스 설정

Firestore Console에서 생성:
- `projects` - `created_at` (DESC)
- `sections` - `order` (ASC)
- `conversations` - `timestamp` (ASC)

---

## 7. API 상세 명세

### 7.1 프로젝트 API

#### POST /api/projects
**설명**: 새 프로젝트 생성

**Request Body**:
```json
{
  "source_type": "url",
  "source_content": "https://example.com/article"
}
```

**Response (201)**:
```json
{
  "id": "proj_abc123",
  "source_type": "url",
  "source_content": "https://example.com/article",
  "summary": null,
  "keywords": null,
  "created_at": "2025-10-23T10:00:00Z",
  "updated_at": "2025-10-23T10:00:00Z",
  "status": "draft"
}
```

#### POST /api/projects/{id}/summarize
**설명**: 프로젝트 소스 요약

**Response (200)**:
```json
{
  "summary": "이 기사는 AI 기술의 발전에 대해 다룹니다...",
  "keywords": ["AI", "기술", "발전", "미래", "혁신"],
  "recommended_card_count": 5
}
```

#### POST /api/projects/{id}/sections
**설명**: 카드뉴스 섹션 자동 생성

**Response (200)**:
```json
{
  "sections": [
    {
      "id": "sec_1",
      "order": 0,
      "type": "title",
      "title": "AI 기술의 미래",
      "content": "우리 삶을 바꿀 혁신"
    },
    {
      "id": "sec_2",
      "order": 1,
      "type": "content",
      "title": "핵심 기술",
      "content": "머신러닝과 딥러닝이 주도하는 변화..."
    }
  ]
}
```

### 7.2 채팅 API

#### POST /api/chat
**Request**:
```json
{
  "project_id": "proj_abc123",
  "user_message": "두 번째 카드를 더 간결하게 만들어줘",
  "current_sections": [...],
  "conversation_history": [...]
}
```

**Response**:
```json
{
  "ai_response": "두 번째 카드의 내용을 간결하게 수정했습니다.",
  "updated_sections": [...],
  "action_taken": "modify"
}
```

---

## 8. 배포 가이드

### 8.1 Backend 배포 (Google Cloud Run)

#### Step 1: Dockerfile 작성
```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY ./app ./app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
```

#### Step 2: Cloud Run 배포
```bash
# Google Cloud 프로젝트 설정
gcloud config set project YOUR_PROJECT_ID

# 이미지 빌드
gcloud builds submit --tag gcr.io/YOUR_PROJECT_ID/cardnews-backend

# Cloud Run 배포
gcloud run deploy cardnews-backend \
  --image gcr.io/YOUR_PROJECT_ID/cardnews-backend \
  --platform managed \
  --region asia-northeast3 \
  --allow-unauthenticated \
  --set-env-vars OPENAI_API_KEY=sk-xxx
```

### 8.2 Frontend 배포 (Firebase Hosting)

```bash
cd frontend
npm run build
firebase deploy --only hosting
```

---

## 9. 테스트 전략

### 9.1 Backend 테스트

#### 단위 테스트 (`pytest`)
```python
# tests/test_scraper.py
import pytest
from app.services.scraper import WebScraper

def test_scrape_url():
    scraper = WebScraper()
    result = scraper.scrape_url('https://example.com')
    
    assert 'title' in result
    assert 'content' in result
    assert len(result['content']) > 0

# tests/test_summarizer.py
def test_summarize():
    summarizer = AISummarizer()
    text = "긴 텍스트..." * 100
    
    result = summarizer.summarize(text)
    
    assert len(result['summary']) <= 200
    assert len(result['keywords']) > 0
```

#### 통합 테스트
```python
# tests/test_api.py
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_create_project():
    response = client.post('/api/projects', json={
        'source_type': 'text',
        'source_content': '테스트 내용입니다.'
    })
    
    assert response.status_code == 201
    assert 'id' in response.json()
```

### 9.2 테스트 커버리지 목표

| 모듈 | 목표 커버리지 |
|------|---------------|
| Services | 90%+ |
| Routers | 80%+ |
| Utils | 85%+ |
| **전체** | **80%+** |

#### 커버리지 측정
```bash
pytest --cov=app --cov-report=html
```

---

## 10. 보안 고려사항

### 10.1 API 키 보호
- ✅ `.env` 파일 사용 (절대 커밋하지 않기)
- ✅ `.gitignore`에 `.env` 추가
- ✅ Cloud Run 환경 변수로 주입

### 10.2 입력 검증
- ✅ URL 유효성 검사
- ✅ 텍스트 길이 제한 (10,000자)
- ✅ SQL Injection 방지 (Firestore는 NoSQL이므로 덜 위험)

### 10.3 Rate Limiting
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@app.post("/api/projects")
@limiter.limit("5/minute")  # 분당 5회 제한
async def create_project():
    ...
```

---

## 11. 성능 최적화

### 11.1 캐싱 전략
- **Redis**: 요약 결과 캐싱 (같은 URL 재요청 시)
- **CDN**: Firebase Hosting은 자동 CDN 제공

### 11.2 비동기 처리
```python
# 긴 작업은 백그라운드로
from fastapi import BackgroundTasks

@app.post("/api/projects/{id}/summarize")
async def summarize(id: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(run_summarization, id)
    return {"message": "요약 작업이 시작되었습니다."}
```

---

## 부록

### A. 환경 변수 전체 목록

#### Backend (.env)
```env
# OpenAI
OPENAI_API_KEY=sk-xxx
OPENAI_MODEL=gpt-4o-mini

# Firebase
FIREBASE_PROJECT_ID=cardnews-xxxxx
FIREBASE_PRIVATE_KEY_PATH=./serviceAccountKey.json

# Server
BACKEND_PORT=8000
ALLOWED_ORIGINS=http://localhost:3000,https://cardnews.web.app

# Limits
MAX_TEXT_LENGTH=10000
RATE_LIMIT_PER_MINUTE=10

# Debug
DEBUG=True
LOG_LEVEL=INFO
```

#### Frontend (.env.local)
```env
NEXT_PUBLIC_API_URL=https://cardnews-backend-xxx.run.app
NEXT_PUBLIC_FIREBASE_API_KEY=AIzaSyXXX
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=cardnews-xxxxx.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=cardnews-xxxxx
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=cardnews-xxxxx.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=123456789
NEXT_PUBLIC_FIREBASE_APP_ID=1:123456789:web:xxx
```

---

**문서 버전**: 1.0  
**최종 업데이트**: 2025-10-23  
**작성자**: CardNews AI Development Team

